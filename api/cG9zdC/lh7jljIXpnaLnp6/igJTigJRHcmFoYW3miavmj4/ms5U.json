{"title":"凸包面积——Graham扫描法","date":"2019-04-21T14:16:02.000Z","slug":"凸包面积——Graham扫描法","updated":"2019-04-21T14:17:04.859Z","content":"<h1 id=\"凸包面积–Graham扫描法\"><a href=\"#凸包面积–Graham扫描法\" class=\"headerlink\" title=\"凸包面积–Graham扫描法\"></a>凸包面积–Graham扫描法</h1><h5 id=\"1-选取p0作为y坐标最小的点，如果y坐标相等，选取x坐标最小的点（即最左下的点）\"><a href=\"#1-选取p0作为y坐标最小的点，如果y坐标相等，选取x坐标最小的点（即最左下的点）\" class=\"headerlink\" title=\"1.选取p0作为y坐标最小的点，如果y坐标相等，选取x坐标最小的点（即最左下的点）\"></a>1.选取p0作为y坐标最小的点，如果y坐标相等，选取x坐标最小的点（即最左下的点）</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n,k=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p[i].y&lt;p[k].y||(p[i].y==p[k].y&amp;&amp;p[i].x&lt;p[k].x))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         k=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">swap(p[<span class=\"number\">0</span>],p[k]);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-对剩余的点相对与p0点的极角进行排序，除极角相等的点，即距离最远的点\"><a href=\"#2-对剩余的点相对与p0点的极角进行排序，除极角相等的点，即距离最远的点\" class=\"headerlink\" title=\"2.对剩余的点相对与p0点的极角进行排序，除极角相等的点，即距离最远的点\"></a>2.对剩余的点相对与p0点的极角进行排序，除极角相等的点，即距离最远的点</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(point a,point b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">float</span> xx=(a.x-p[<span class=\"number\">0</span>].x)*(b.y-p[<span class=\"number\">0</span>].y)-(a.y-p[<span class=\"number\">0</span>].y)*(b.x-p[<span class=\"number\">0</span>].x);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(xx)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a.x-p[<span class=\"number\">0</span>].x)*(b.y-p[<span class=\"number\">0</span>].y)&lt;(a.y-p[<span class=\"number\">0</span>].y)*(b.x-p[<span class=\"number\">0</span>].x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a.x&lt;b.x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-折线段拐向判断，若没有左转的时候出栈点，否则入栈\"><a href=\"#3-折线段拐向判断，若没有左转的时候出栈点，否则入栈\" class=\"headerlink\" title=\"3.折线段拐向判断，若没有左转的时候出栈点，否则入栈\"></a>3.折线段拐向判断，若没有左转的时候出栈点，否则入栈</h5><p>差乘<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">ss</span><span class=\"params\">(point a,point b,point c)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;     </span><br><span class=\"line\">     <span class=\"keyword\">float</span> x1=b.x-a.x;</span><br><span class=\"line\">     <span class=\"keyword\">float</span> y1=b.y-a.y;</span><br><span class=\"line\">     <span class=\"keyword\">float</span> x2=c.x-a.x;</span><br><span class=\"line\">     <span class=\"keyword\">float</span> y2=c.y-a.y;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> x1*y2-x2*y1; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>判断是否入栈<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pp[<span class=\"number\">0</span>]=p[<span class=\"number\">0</span>];</span><br><span class=\"line\">      pp[<span class=\"number\">1</span>]=p[<span class=\"number\">1</span>];</span><br><span class=\"line\">      pp[<span class=\"number\">2</span>]=p[<span class=\"number\">2</span>];</span><br><span class=\"line\">      <span class=\"keyword\">int</span> top=<span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>;i&lt;n;i++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span>(ss(pp[top<span class=\"number\">-1</span>],pp[top],p[i])&gt;=<span class=\"number\">0</span>)top--;</span><br><span class=\"line\">          pp[++top]=p[i];</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4-计算面积\"><a href=\"#4-计算面积\" class=\"headerlink\" title=\"4.计算面积\"></a>4.计算面积</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">while</span>(top&gt;=<span class=\"number\">2</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">float</span> m=ss(pp[<span class=\"number\">0</span>],pp[top<span class=\"number\">-1</span>],pp[top<span class=\"number\">-2</span>])/<span class=\"number\">2.0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(m&lt;<span class=\"number\">0</span>)m=<span class=\"number\">0</span>-m;</span><br><span class=\"line\">     ans+=m;</span><br><span class=\"line\">     top--;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>就想用一个白色的凸多边形把墙上的墨点盖住。你能告诉麦兜最小需要面积多大的凸多边形才能把这些墨点盖住吗？<br>现在，给出了这些墨点的坐标，请帮助麦兜计算出覆盖这些墨点的最小凸多边形的面积。<br>输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多组测试数据。第一行是一个整数T，表明一共有T组测试数据。</span><br><span class=\"line\">每组测试数据的第一行是一个正整数N(0&lt; N &lt; = 105)，表明了墨点的数量。接下来的N行每行包含了两个整数Xi和Yi（0&lt;=Xi,Yi&lt;=2000），表示每个墨点的坐标。每行的坐标间可能包含多个空格。</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每行输出一组测试数据的结果，只需输出最小凸多边形的面积。面积是个实数，小数点后面保留一位即可，不需要多余的空格。</span><br></pre></td></tr></table></figure></p>\n<p>样例输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">0 0</span><br><span class=\"line\">1 0</span><br><span class=\"line\">0 1</span><br><span class=\"line\">1 1</span><br><span class=\"line\">2</span><br><span class=\"line\">0 0</span><br><span class=\"line\">0 1</span><br></pre></td></tr></table></figure></p>\n<p>样例输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.0</span><br><span class=\"line\">0.0</span><br></pre></td></tr></table></figure></p>\n<p><code>`</code>c++</p>\n<p> #include&lt;bits/stdc++.h&gt;<br> using namespace std;<br> struct point<br>  {<br>      float x;<br>      float y;<br>  }p[110],pp[110]; </p>\n<p>//根据角排序<br>bool cmp(point a,point b)<br>{<br>    float xx=(a.x-p[0].x)<em>(b.y-p[0].y)-(a.y-p[0].y)</em>(b.x-p[0].x);<br>    if(xx&gt;0||xx==0&amp;&amp;a.x&lt;b.x)<br>    {<br>        return true;<br>    }<br>    else return false;<br>}//差积<br>float ss(point a,point b,point c)<br>{<br>    float x1=b.x-a.x;<br>    float y1=b.y-a.y;<br>    float x2=c.x-a.x;<br>    float y2=c.y-a.y;<br>    return x2<em>y1-x1</em>y2;}<br>int main()<br>{<br>    int t;<br>    cin&gt;&gt;t;<br>    while(t–)<br>    {<br>        int n,k=0;<br>        cin&gt;&gt;n;<br>        for(int i=0;i&lt;n;i++)<br>        {<br>            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;<br>            if(p[i].y&lt;p[k].y||(p[i].y==p[k].y&amp;&amp;p[i].x&lt;p[k].x))<br>            {<br>                k=i;<br>            }<br>        }<br>        swap(p[0],p[k]);<br>        sort(p+1,p+n,cmp);<br>        pp[0]=p[0];<br>        pp[1]=p[1];<br>        pp[2]=p[2];<br>        int top=2;<br>        for(int i=3;i&lt;n;i++)<br>        {<br>            while(ss(pp[top-1],pp[top],p[i])&gt;=0)top–;<br>            pp[++top]=p[i];<br>        }<br>        float ans=0;<br>        if(n&lt;=2)<br>        {<br>            printf(“0.0\\n”);<br>            continue;<br>        }<br>        while(top&gt;=2)<br>        {<br>            float m=ss(pp[0],pp[top-1],pp[top])/2.0;<br>            if(m&lt;0)m=0-m;<br>            ans+=m;<br>            top–;<br>        }<br>        printf(“%.1lf\\n”,ans);<br>    }<br>}</p>\n","prev":{"title":"合并排序（分治法）","slug":"合并排序（分治法）"},"next":{"title":"C++中set用法","slug":"C-中set用法"},"link":"http://starlx.cn/post/凸包面积——Graham扫描法/","toc":[{"title":"凸包面积–Graham扫描法","id":"凸包面积–Graham扫描法","index":"1"}]}